<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>beeline API documentation</title>
    <meta name="description" content="module beeline" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>

  <style type="text/css">
  .codehilite .hll { background-color: #ffffcc }
.codehilite  { background: #f8f8f8; }
.codehilite .c { color: #408080; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #FF0000 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666666 } /* Operator */
.codehilite .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #BC7A00 } /* Comment.Preproc */
.codehilite .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #408080; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #408080; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .gr { color: #FF0000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #00A000 } /* Generic.Inserted */
.codehilite .go { color: #888888 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #0044DD } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #7D9029 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.codehilite .no { color: #880000 } /* Name.Constant */
.codehilite .nd { color: #AA22FF } /* Name.Decorator */
.codehilite .ni { color: #999999; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #0000FF } /* Name.Function */
.codehilite .nl { color: #A0A000 } /* Name.Label */
.codehilite .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite .mb { color: #666666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666666 } /* Literal.Number.Float */
.codehilite .mh { color: #666666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #BB6688 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #0000FF } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666666 } /* Literal.Number.Integer.Long */
  </style>

  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#beeline.USER_AGENT_ADDITION">USER_AGENT_ADDITION</a></li>
    <li class="mono"><a href="#beeline.VERSION">VERSION</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#beeline.add">add</a></li>
    <li class="mono"><a href="#beeline.add_context">add_context</a></li>
    <li class="mono"><a href="#beeline.add_context_field">add_context_field</a></li>
    <li class="mono"><a href="#beeline.add_field">add_field</a></li>
    <li class="mono"><a href="#beeline.add_rollup_field">add_rollup_field</a></li>
    <li class="mono"><a href="#beeline.add_trace_field">add_trace_field</a></li>
    <li class="mono"><a href="#beeline.close">close</a></li>
    <li class="mono"><a href="#beeline.finish_span">finish_span</a></li>
    <li class="mono"><a href="#beeline.finish_trace">finish_trace</a></li>
    <li class="mono"><a href="#beeline.get_beeline">get_beeline</a></li>
    <li class="mono"><a href="#beeline.get_responses_queue">get_responses_queue</a></li>
    <li class="mono"><a href="#beeline.in_async_code">in_async_code</a></li>
    <li class="mono"><a href="#beeline.init">init</a></li>
    <li class="mono"><a href="#beeline.marshal_trace_context">marshal_trace_context</a></li>
    <li class="mono"><a href="#beeline.new_event">new_event</a></li>
    <li class="mono"><a href="#beeline.remove_context_field">remove_context_field</a></li>
    <li class="mono"><a href="#beeline.remove_trace_field">remove_trace_field</a></li>
    <li class="mono"><a href="#beeline.send_all">send_all</a></li>
    <li class="mono"><a href="#beeline.send_event">send_event</a></li>
    <li class="mono"><a href="#beeline.send_now">send_now</a></li>
    <li class="mono"><a href="#beeline.start_span">start_span</a></li>
    <li class="mono"><a href="#beeline.start_trace">start_trace</a></li>
    <li class="mono"><a href="#beeline.traced">traced</a></li>
    <li class="mono"><a href="#beeline.traced_thread">traced_thread</a></li>
    <li class="mono"><a href="#beeline.tracer">tracer</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#beeline.Beeline">Beeline</a></span>
        
          
  <ul>
    <li class="mono"><a href="#beeline.Beeline.__init__">__init__</a></li>
    <li class="mono"><a href="#beeline.Beeline.add">add</a></li>
    <li class="mono"><a href="#beeline.Beeline.add_field">add_field</a></li>
    <li class="mono"><a href="#beeline.Beeline.close">close</a></li>
    <li class="mono"><a href="#beeline.Beeline.get_responses_queue">get_responses_queue</a></li>
    <li class="mono"><a href="#beeline.Beeline.log">log</a></li>
    <li class="mono"><a href="#beeline.Beeline.new_event">new_event</a></li>
    <li class="mono"><a href="#beeline.Beeline.send_all">send_all</a></li>
    <li class="mono"><a href="#beeline.Beeline.send_event">send_event</a></li>
    <li class="mono"><a href="#beeline.Beeline.send_now">send_now</a></li>
    <li class="mono"><a href="#beeline.Beeline.traced">traced</a></li>
    <li class="mono"><a href="#beeline.Beeline.traced_thread">traced_thread</a></li>
    <li class="mono"><a href="#beeline.Beeline.tracer">tracer</a></li>
  </ul>

        </li>
      </ul>
    </li>

    <li class="set"><h3><a href="#header-submodules">Sub-modules</a></h3>
      <ul>
        <li class="mono"><a href="aiotrace.m.html">beeline.aiotrace</a></li>
        <li class="mono"><a href="internal.m.html">beeline.internal</a></li>
        <li class="mono"><a href="middleware/index.html">beeline.middleware</a></li>
        <li class="mono"><a href="patch/index.html">beeline.patch</a></li>
        <li class="mono"><a href="test_async.m.html">beeline.test_async</a></li>
        <li class="mono"><a href="test_internal.m.html">beeline.test_internal</a></li>
        <li class="mono"><a href="test_suite.m.html">beeline.test_suite</a></li>
        <li class="mono"><a href="trace.m.html">beeline.trace</a></li>
        <li class="mono"><a href="version.m.html">beeline.version</a></li>
      </ul>
    </li>
    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">beeline</span> module</h1>
  <p>module beeline</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline', this);">Show source &equiv;</a></p>
  <div id="source-beeline" class="source">
    <div class="codehilite"><pre><span></span><span class="sd">&#39;&#39;&#39; module beeline &#39;&#39;&#39;</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>

<span class="kn">from</span> <span class="nn">libhoney</span> <span class="kn">import</span> <span class="n">Client</span>
<span class="kn">from</span> <span class="nn">beeline.trace</span> <span class="kn">import</span> <span class="n">SynchronousTracer</span>
<span class="kn">from</span> <span class="nn">beeline.version</span> <span class="kn">import</span> <span class="n">VERSION</span>
<span class="kn">from</span> <span class="nn">beeline</span> <span class="kn">import</span> <span class="n">internal</span>
<span class="c1"># pyflakes</span>
<span class="k">assert</span> <span class="n">internal</span>

<span class="n">USER_AGENT_ADDITION</span> <span class="o">=</span> <span class="s2">&quot;beeline-python/</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">VERSION</span>

<span class="c1"># This is the global beeline created by init</span>
<span class="n">_GBL</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1"># This is the PID that initialized the beeline.</span>
<span class="n">_INITPID</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">asyncio</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>  <span class="c1"># pylint: disable=no-member</span>
    <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="kn">from</span> <span class="nn">beeline.aiotrace</span> <span class="kn">import</span> <span class="n">AsyncioTracer</span><span class="p">,</span> <span class="n">traced_impl</span><span class="p">,</span> <span class="n">untraced</span>
    <span class="k">assert</span> <span class="n">untraced</span>

    <span class="k">def</span> <span class="nf">in_async_code</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Return whether we are running inside an asynchronous task.</span>

<span class="sd">        We use this information to determine which tracer</span>
<span class="sd">        implementation to use.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>  <span class="c1"># pylint: disable=no-member</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

<span class="k">except</span> <span class="p">(</span><span class="ne">ImportError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
    <span class="c1"># Use these non-async versions if we don&#39;t have asyncio.</span>
    <span class="kn">from</span> <span class="nn">beeline.trace</span> <span class="kn">import</span> <span class="n">traced_impl</span>

    <span class="k">def</span> <span class="nf">in_async_code</span><span class="p">():</span>
        <span class="k">return</span> <span class="kc">False</span>

<span class="k">class</span> <span class="nc">Beeline</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">writekey</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">service_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
            <span class="n">tracer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">api_host</span><span class="o">=</span><span class="s1">&#39;https://api.honeycomb.io&#39;</span><span class="p">,</span>
            <span class="n">max_concurrent_batches</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_batch_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">send_frequency</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
            <span class="n">block_on_send</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">block_on_response</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">transmission_impl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sampler_hook</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">presend_hook</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">client</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">presend_hook</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler_hook</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">debug</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_logger</span><span class="p">()</span>

        <span class="c1"># allow setting some values from the environment</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">writekey</span><span class="p">:</span>
            <span class="n">writekey</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;HONEYCOMB_WRITEKEY&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">dataset</span><span class="p">:</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;HONEYCOMB_DATASET&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">service_name</span><span class="p">:</span>
            <span class="n">service_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;HONEYCOMB_SERVICE&#39;</span><span class="p">,</span> <span class="n">dataset</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span>
            <span class="n">writekey</span><span class="o">=</span><span class="n">writekey</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span>
            <span class="n">api_host</span><span class="o">=</span><span class="n">api_host</span><span class="p">,</span> <span class="n">max_concurrent_batches</span><span class="o">=</span><span class="n">max_concurrent_batches</span><span class="p">,</span>
            <span class="n">max_batch_size</span><span class="o">=</span><span class="n">max_batch_size</span><span class="p">,</span> <span class="n">send_frequency</span><span class="o">=</span><span class="n">send_frequency</span><span class="p">,</span>
            <span class="n">block_on_send</span><span class="o">=</span><span class="n">block_on_send</span><span class="p">,</span> <span class="n">block_on_response</span><span class="o">=</span><span class="n">block_on_response</span><span class="p">,</span>
            <span class="n">transmission_impl</span><span class="o">=</span><span class="n">transmission_impl</span><span class="p">,</span>
            <span class="n">user_agent_addition</span><span class="o">=</span><span class="n">USER_AGENT_ADDITION</span><span class="p">,</span>
            <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;initialized honeycomb client: writekey=</span><span class="si">%s</span><span class="s1"> dataset=</span><span class="si">%s</span><span class="s1"> service_name=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                   <span class="n">writekey</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">service_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">writekey</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;writekey not set! set the writekey if you want to send data to honeycomb&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dataset</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;dataset not set! set a value for dataset if you want to send data to honeycomb&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">add_field</span><span class="p">(</span><span class="s1">&#39;service_name&#39;</span><span class="p">,</span> <span class="n">service_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">add_field</span><span class="p">(</span><span class="s1">&#39;meta.beeline_version&#39;</span><span class="p">,</span> <span class="n">VERSION</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">add_field</span><span class="p">(</span><span class="s1">&#39;meta.local_hostname&#39;</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">gethostname</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">in_async_code</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span> <span class="o">=</span> <span class="n">AsyncioTracer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span> <span class="o">=</span> <span class="n">SynchronousTracer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">register_hooks</span><span class="p">(</span><span class="n">presend</span><span class="o">=</span><span class="n">presend_hook</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="n">sampler_hook</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler_hook</span> <span class="o">=</span> <span class="n">sampler_hook</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">presend_hook</span> <span class="o">=</span> <span class="n">presend_hook</span>

    <span class="k">def</span> <span class="nf">send_now</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; DEPRECATED - to be removed in a future release</span>

<span class="sd">        Create an event and enqueue it immediately. Does not work with</span>
<span class="sd">        `beeline.add_field` - this is equivalent to calling `libhoney.send_now`</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">new_event</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">ev</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_run_hooks_and_send</span><span class="p">(</span><span class="n">ev</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Add a field to the currently active span.</span>

<span class="sd">        `beeline.add_field(&quot;my field&quot;, &quot;my value&quot;)`</span>

<span class="sd">        If a field is being attributed to the wrong span/event,</span>
<span class="sd">        make sure that `new_event` and `close_event` calls are matched.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># fetch the current event from our tracer</span>
        <span class="n">span</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">get_active_span</span><span class="p">()</span>
        <span class="c1"># if there are no spans, this is a noop</span>
        <span class="k">if</span> <span class="n">span</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">span</span><span class="o">.</span><span class="n">add_context_field</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Similar to add_field(), but allows you to add a number of name:value pairs</span>
<span class="sd">        to the currently active event at the same time.</span>

<span class="sd">        `beeline.add({ &quot;first_field&quot;: &quot;a&quot;, &quot;second_field&quot;: &quot;b&quot;})`</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># fetch the current event from the tracer</span>
        <span class="n">span</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">get_active_span</span><span class="p">()</span>
        <span class="c1"># if there are no spans, this is a noop</span>
        <span class="k">if</span> <span class="n">span</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">span</span><span class="o">.</span><span class="n">add_context</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">trace_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">trace_id</span><span class="o">=</span><span class="n">trace_id</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="n">parent_id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">new_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">trace_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; DEPRECATED: Helper method that wraps `start_trace` and</span>
<span class="sd">        `start_span`. It is better to use these methods as it provides</span>
<span class="sd">        better control and context around how traces are implemented in your</span>
<span class="sd">        app.</span>

<span class="sd">        Creates a new span, populating it with the given data if</span>
<span class="sd">        supplied. If no trace is running, a new trace will be started,</span>
<span class="sd">        otherwise the event will be added as a span of the existing trace.</span>

<span class="sd">        To send the event, call `beeline.send_event()`. There should be a</span>
<span class="sd">        `send_event()` for each call to `new_event()`, or tracing and</span>
<span class="sd">        `add` and `add_field` will not work correctly.</span>

<span class="sd">        If trace_name is specified, will set the &quot;name&quot; field of the current span,</span>
<span class="sd">        which is used in the trace visualizer.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">trace_name</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trace_name</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">get_active_trace_id</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">start_span</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">start_trace</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">send_event</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; DEPRECATED: Sends the currently active event (current span),</span>
<span class="sd">        if it exists.</span>

<span class="sd">        There must be one call to `send_event` for each call to `new_event`.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">span</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">get_active_span</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">span</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">span</span><span class="o">.</span><span class="n">is_root</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">finish_trace</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">finish_span</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">send_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; send all spans in the trace stack, regardless of their</span>
<span class="sd">        state</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">span</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">get_active_span</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">span</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">span</span><span class="o">.</span><span class="n">is_root</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">finish_trace</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">finish_span</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>
            <span class="n">span</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">get_active_span</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">traced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">trace_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">traced_impl</span><span class="p">(</span><span class="n">tracer_fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tracer</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">trace_id</span><span class="o">=</span><span class="n">trace_id</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="n">parent_id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">traced_thread</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
        <span class="n">trace_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">_trace</span> <span class="o">=</span> <span class="n">trace_copy</span>
            <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">wrapped</span>

    <span class="k">def</span> <span class="nf">_run_hooks_and_send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ev</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; internal - run any defined hooks on the event and send &#39;&#39;&#39;</span>
        <span class="n">presampled</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler_hook</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;executing sampler hook on event ev = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ev</span><span class="o">.</span><span class="n">fields</span><span class="p">())</span>
            <span class="n">keep</span><span class="p">,</span> <span class="n">new_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler_hook</span><span class="p">(</span><span class="n">ev</span><span class="o">.</span><span class="n">fields</span><span class="p">())</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">keep</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;skipping event due to sampler hook sampling ev = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ev</span><span class="o">.</span><span class="n">fields</span><span class="p">())</span>
                <span class="k">return</span>
            <span class="n">ev</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="n">new_rate</span>
            <span class="n">presampled</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">presend_hook</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;executing presend hook on event ev = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ev</span><span class="o">.</span><span class="n">fields</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">presend_hook</span><span class="p">(</span><span class="n">ev</span><span class="o">.</span><span class="n">fields</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">presampled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;enqueuing presampled event ev = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ev</span><span class="o">.</span><span class="n">fields</span><span class="p">())</span>
            <span class="n">ev</span><span class="o">.</span><span class="n">send_presampled</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;enqueuing event ev = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ev</span><span class="o">.</span><span class="n">fields</span><span class="p">())</span>
            <span class="n">ev</span><span class="o">.</span><span class="n">send</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_init_logger</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;honeycomb-beeline&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">()</span>
        <span class="n">ch</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
        <span class="n">formatter</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%(asctime)s</span><span class="s1"> - </span><span class="si">%(name)s</span><span class="s1"> - </span><span class="si">%(levelname)s</span><span class="s1"> - </span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">ch</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_responses_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">responses</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="n">writekey</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">service_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">tracer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
         <span class="n">sample_rate</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">api_host</span><span class="o">=</span><span class="s1">&#39;https://api.honeycomb.io&#39;</span><span class="p">,</span> <span class="n">transmission_impl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
         <span class="n">sampler_hook</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">presend_hook</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; initialize the honeycomb beeline. This will initialize a libhoney</span>
<span class="sd">    client local to this module, and a tracer to track traces and spans.</span>

<span class="sd">    Args:</span>
<span class="sd">    - `writekey`: the authorization key for your team on Honeycomb. Find your team</span>
<span class="sd">            write key at [https://ui.honeycomb.io/account](https://ui.honeycomb.io/account)</span>
<span class="sd">    - `dataset`: the name of the default dataset to which to write</span>
<span class="sd">    - `sample_rate`: the default sample rate. 1 / `sample_rate` events will be sent.</span>
<span class="sd">    - `transmission_impl`: if set, override the default transmission implementation</span>
<span class="sd">            (for example, TornadoTransmission)</span>
<span class="sd">    - `sampler_hook`: accepts a function to be called just before each event is sent.</span>
<span class="sd">            The function should accept a dictionary of event fields, and return a tuple</span>
<span class="sd">            of type (bool, int). The first item indicates whether or not the event</span>
<span class="sd">            should be sent, and the second indicates the updated sample rate to use.</span>
<span class="sd">    - `presend_hook`: accepts a function to be called just before each event is sent.</span>
<span class="sd">            The functon should accept a dictionary of event fields, and can be used</span>
<span class="sd">            to add new fields, modify/scrub existing fields, or drop fields. This</span>
<span class="sd">            function is called after sampler_hook, if sampler_hook is set.</span>

<span class="sd">    If in doubt, just set `writekey` and `dataset` and move on!</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">global</span> <span class="n">_GBL</span>
    <span class="k">global</span> <span class="n">_INITPID</span>
    <span class="n">pid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">_GBL</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">pid</span> <span class="o">==</span> <span class="n">_INITPID</span><span class="p">:</span>
            <span class="n">_GBL</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;beeline already initialized! skipping initialization&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">_GBL</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;beeline already initialized, but process ID has changed (was </span><span class="si">{}</span><span class="s2">, now </span><span class="si">{}</span><span class="s2">). Reinitializing.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_INITPID</span><span class="p">,</span> <span class="n">pid</span><span class="p">))</span>
        <span class="n">_GBL</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">_GBL</span> <span class="o">=</span> <span class="n">Beeline</span><span class="p">(</span>
        <span class="n">writekey</span><span class="o">=</span><span class="n">writekey</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span>
        <span class="n">api_host</span><span class="o">=</span><span class="n">api_host</span><span class="p">,</span> <span class="n">transmission_impl</span><span class="o">=</span><span class="n">transmission_impl</span><span class="p">,</span>
        <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">presend_hook</span><span class="o">=</span><span class="n">presend_hook</span><span class="p">,</span> <span class="n">sampler_hook</span><span class="o">=</span><span class="n">sampler_hook</span><span class="p">,</span>
        <span class="n">service_name</span><span class="o">=</span><span class="n">service_name</span><span class="p">,</span>
        <span class="c1"># since we&#39;ve simplified the init function signature a bit,</span>
        <span class="c1"># pass on other args for backwards compatibility</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>
    <span class="c1"># Store the PID that initialized the beeline globally. If the beeline was initialized in another</span>
    <span class="c1"># process that was later forked, we can use this to detect it and reinitialize the client (and the transmission</span>
    <span class="c1"># thread).</span>
    <span class="n">_INITPID</span> <span class="o">=</span> <span class="n">pid</span>

<span class="k">def</span> <span class="nf">send_now</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Create an event and enqueue it immediately. Does not work with</span>
<span class="sd">    `beeline.add_field` - this is equivalent to calling `libhoney.send_now`</span>

<span class="sd">    Args:</span>
<span class="sd">    - `data`: dictionary of field names (strings) to field values to include</span>
<span class="sd">              in the event</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># no-op if we&#39;re not initialized</span>
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">send_now</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">add_field</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; DEPRECATED: use `add_context_field`</span>

<span class="sd">    Args:</span>
<span class="sd">    - `data`: dictionary of field names (strings) to field values to add</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">_GBL</span><span class="p">:</span>
        <span class="n">_GBL</span><span class="o">.</span><span class="n">add_field</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;DEPRECATED: use `add_context`</span>

<span class="sd">    Args:</span>
<span class="sd">    - `data`: dictionary of field names (strings) to field values to add</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">add_context</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Similar to add_context_field(), but allows you to add a number of name:value pairs</span>
<span class="sd">    to the currently active event at the same time.</span>

<span class="sd">    `beeline.add_context({ &quot;first_field&quot;: &quot;a&quot;, &quot;second_field&quot;: &quot;b&quot;})`</span>

<span class="sd">    Args:</span>
<span class="sd">    - `data`: dictionary of field names (strings) to field values to add</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">add_context</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">add_context_field</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Add a field to the currently active span. For example, if you are</span>
<span class="sd">    using django and wish to add additional context to the current request</span>
<span class="sd">    before it is sent to Honeycomb:</span>

<span class="sd">    `beeline.add_context_field(&quot;my field&quot;, &quot;my value&quot;)`</span>

<span class="sd">    Args:</span>
<span class="sd">    - `name`: Name of field to add</span>
<span class="sd">    - `value`: Value of new field</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">add_context_field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">remove_context_field</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Remove a single field from the current span.</span>

<span class="sd">    ```</span>
<span class="sd">    beeline.add_context({ &quot;first_field&quot;: &quot;a&quot;, &quot;second_field&quot;: &quot;b&quot;})</span>
<span class="sd">    beeline.remove_context_field(&quot;second_field&quot;)</span>

<span class="sd">    Args:</span>
<span class="sd">    - `name`: Name of field to remove</span>
<span class="sd">    ```</span>
<span class="sd">     &#39;&#39;&#39;</span>
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">remove_context_field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">add_rollup_field</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; AddRollupField adds a key/value pair to the current span. If it is called repeatedly</span>
<span class="sd">    on the same span, the values will be summed together.  Additionally, this</span>
<span class="sd">    field will be summed across all spans and added to the trace as a total. It</span>
<span class="sd">    is especially useful for doing things like adding the duration spent talking</span>
<span class="sd">    to a specific external service - eg database time. The root span will then</span>
<span class="sd">    get a field that represents the total time spent talking to the database from</span>
<span class="sd">    all of the spans that are part of the trace.</span>

<span class="sd">    Args:</span>
<span class="sd">    - `name`: Name of field to add</span>
<span class="sd">    - `value`: Numeric (float) value of new field</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">add_rollup_field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">add_trace_field</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Similar to `add_context_field` - adds a field to the current span, but</span>
<span class="sd">    also to all other future spans in this trace. Trace context fields will be</span>
<span class="sd">    propagated to downstream services if using instrumented libraries</span>
<span class="sd">    like `requests`.</span>

<span class="sd">    Args:</span>
<span class="sd">    - `name`: Name of field to add</span>
<span class="sd">    - `value`: Value of new field</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">add_trace_field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">remove_trace_field</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Removes a trace context field from the current span. This will not</span>
<span class="sd">    affect  other existing spans, but will prevent the field from being</span>
<span class="sd">    propagated to new spans.</span>

<span class="sd">    Args:</span>
<span class="sd">    - `name`: Name of field to remove</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">remove_trace_field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">tracer</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">trace_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    When used in a context manager, creates a span for the contained</span>
<span class="sd">    code. If a trace is ongoing, will add a new child span under the currently</span>
<span class="sd">    running span. If no trace is ongoing, will start a new trace.</span>

<span class="sd">    Example use:</span>

<span class="sd">    ```</span>
<span class="sd">    with tracer(name=&quot;my expensive computation&quot;):</span>
<span class="sd">        recursive_fib(100)</span>
<span class="sd">    ```</span>

<span class="sd">    Args:</span>
<span class="sd">    - `name`: a descriptive name for the this trace span, i.e. &quot;database query for user&quot;</span>
<span class="sd">    - `trace_id`: the trace_id to use. If None, will be automatically generated if no</span>
<span class="sd">       current trace is ongoing. Use this if you want to explicitly resume a trace</span>
<span class="sd">       in this application that was initiated in another application, and you have</span>
<span class="sd">       the upstream trace_id.</span>
<span class="sd">    - `parent_id`: If trace_id is set, will populate the root span&#39;s parent</span>
<span class="sd">        with this id.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bl</span><span class="o">.</span><span class="n">tracer</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">trace_id</span><span class="o">=</span><span class="n">trace_id</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="n">parent_id</span><span class="p">)</span>

    <span class="c1"># if the beeline is not initialized, build a dummy function</span>
    <span class="c1"># that will work as a context manager and call that</span>
    <span class="nd">@contextmanager</span>
    <span class="k">def</span> <span class="nf">_noop_cm</span><span class="p">():</span>
        <span class="k">yield</span>

    <span class="k">return</span> <span class="n">_noop_cm</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">start_trace</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">trace_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent_span_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Start a trace, returning the root span. To finish the trace, pass the span</span>
<span class="sd">    to `finish_trace`. If you are using the beeline middleware plugins, such as for</span>
<span class="sd">    django, flask, or AWS lambda, you will want to use `start_span` instead, as</span>
<span class="sd">    `start_trace` is called at the start of the request.</span>

<span class="sd">    Args:</span>
<span class="sd">    - `context`: optional dictionary of event fields to populate the root span with</span>
<span class="sd">    - `trace_id`: the trace_id to use. If None, will be automatically generated.</span>
<span class="sd">        Use this if you want to explicitly resume trace in this application that was</span>
<span class="sd">        initiated in another application, and you have the upstream trace_id.</span>
<span class="sd">    - `parent_span_id`: If trace_id is set, will populate the root span&#39;s parent</span>
<span class="sd">        with this id.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">start_trace</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">,</span> <span class="n">trace_id</span><span class="o">=</span><span class="n">trace_id</span><span class="p">,</span> <span class="n">parent_span_id</span><span class="o">=</span><span class="n">parent_span_id</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">finish_trace</span><span class="p">(</span><span class="n">span</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Explicitly finish a trace. If you started a trace with `start_trace`, you must call</span>
<span class="sd">    this to close the trace and send the root span. If you are using the beeline middleware plugins,</span>
<span class="sd">    such as django, flask, or AWS lambda, you can skip this step as the trace will be closed for</span>
<span class="sd">    you.</span>

<span class="sd">    Args:</span>
<span class="sd">    - `span`: Span object that was returned by `start_trace`</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">finish_trace</span><span class="p">(</span><span class="n">span</span><span class="o">=</span><span class="n">span</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">start_span</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Start a new span and return the span object. Returns None if no trace is active.</span>
<span class="sd">    For each `start_span`, there should be one call to `close_span`. Child spans should</span>
<span class="sd">    also be closed before parent spans. Closing spans out of order will lead to strange</span>
<span class="sd">    results and can break the bookkeeping needed to preserve trace structure. For example:</span>

<span class="sd">    ```</span>
<span class="sd">    parent_span = beeline.start_span()</span>
<span class="sd">    # this span is a child of the last span created</span>
<span class="sd">    child_span = beeline.start_span()</span>
<span class="sd">    beeline.finish_span(child_span)</span>
<span class="sd">    beeline.finish_span(parent_span)</span>
<span class="sd">    ```</span>

<span class="sd">    Args:</span>
<span class="sd">    - `context`: optional dictionary of event fields to populate the span with</span>
<span class="sd">    - `parent_id`: ID of parent span - use this only if you have a very good reason to</span>
<span class="sd">        do so.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">start_span</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="n">parent_id</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">finish_span</span><span class="p">(</span><span class="n">span</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Finish the provided span, sending the associated event data to Honeycomb.</span>

<span class="sd">    For each `start_span`, there should be one call to `finish_span`.</span>

<span class="sd">    Args:</span>
<span class="sd">    - `span`: Span object that was returned by `start_trace`</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">finish_span</span><span class="p">(</span><span class="n">span</span><span class="o">=</span><span class="n">span</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">marshal_trace_context</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns a serialized form of the current trace context (including the trace</span>
<span class="sd">    id and the current span), encoded as a string. You can use this to propagate</span>
<span class="sd">    trace context to other services.</span>

<span class="sd">    Example:</span>

<span class="sd">    ```</span>
<span class="sd">    trace_context = beeline.marshal_trace_context()</span>
<span class="sd">    headers = {&#39;X-Honeycomb-Trace&#39;: trace_context}</span>
<span class="sd">    requests.get(&quot;http://...&quot;, headers=headers)</span>
<span class="sd">    ```</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">marshal_trace_context</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">new_event</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">trace_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; DEPRECATED: Helper method that wraps `start_trace` and</span>
<span class="sd">    `start_span`. It is better to use these methods as it provides</span>
<span class="sd">    better control and context around how traces are implemented in your</span>
<span class="sd">    app.</span>

<span class="sd">    Creates a new span, populating it with the given data if</span>
<span class="sd">    supplied. If no trace is running, a new trace will be started,</span>
<span class="sd">    otherwise the event will be added as a span of the existing trace.</span>

<span class="sd">    To send the event, call `beeline.send_event()`. There should be a</span>
<span class="sd">    `send_event()` for each call to `new_event()`, or tracing and</span>
<span class="sd">    `add` and `add_field` will not work correctly.</span>

<span class="sd">    If trace_name is specified, will set the &quot;name&quot; field of the current span,</span>
<span class="sd">    which is used in the trace visualizer.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">new_event</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">trace_name</span><span class="o">=</span><span class="n">trace_name</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">send_event</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39; DEPRECATED: Sends the currently active event (current span),</span>
<span class="sd">    if it exists.</span>

<span class="sd">    There must be one call to `send_event` for each call to `new_event`.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">send_event</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">send_all</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39; send all spans in the trace stack, regardless of their</span>
<span class="sd">    state. You might use this in a catch-all error handler</span>
<span class="sd">    along with `beeline.close()` to send all events before the program</span>
<span class="sd">    terminates abruptly.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">send_all</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">get_beeline</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">_GBL</span>

<span class="k">def</span> <span class="nf">get_responses_queue</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns a queue from which you can read a record of response info from</span>
<span class="sd">    each event sent. Responses will be dicts with the following keys:</span>
<span class="sd">        - `status_code` - the HTTP response from the api (eg. 200 or 503)</span>
<span class="sd">        - `duration` - how long it took to POST this event to the api, in ms</span>
<span class="sd">        - `metadata` - pass through the metadata you added on the initial event</span>
<span class="sd">        - `body` - the content returned by API (will be empty on success)</span>
<span class="sd">        - `error` - in an error condition, this is filled with the error message</span>
<span class="sd">    When the Client&#39;s `close` method is called, a None will be inserted on</span>
<span class="sd">    the queue, indicating that no further responses will be written.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bl</span><span class="o">.</span><span class="n">get_responses_queue</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">close</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39; close the beeline and libhoney client, flushing any unsent events. &#39;&#39;&#39;</span>
    <span class="k">global</span> <span class="n">_GBL</span>
    <span class="k">if</span> <span class="n">_GBL</span><span class="p">:</span>
        <span class="n">_GBL</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">_GBL</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">def</span> <span class="nf">traced</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">trace_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Function decorator to wrap an entire function in a trace span. If no trace</span>
<span class="sd">    is active in the current thread, starts a new trace, and the wrapping span</span>
<span class="sd">    will be a root span. If a trace is active, creates a child span of the</span>
<span class="sd">    existing trace.</span>

<span class="sd">    Example use:</span>

<span class="sd">    ```</span>
<span class="sd">    @traced(name=&quot;my_expensive_function&quot;)</span>
<span class="sd">    def my_func(n):</span>
<span class="sd">        recursive_fib(n)</span>

<span class="sd">    my_func(100)</span>
<span class="sd">    ```</span>

<span class="sd">    Args:</span>
<span class="sd">    - `name`: a descriptive name for the this trace span, i.e. &quot;function_name&quot;. This is required.</span>
<span class="sd">    - `trace_id`: the trace_id to use. If None, will be automatically generated.</span>
<span class="sd">        Use this if you want to explicitly resume a trace in this application that was</span>
<span class="sd">        initiated in another application, and you have the upstream trace_id.</span>
<span class="sd">    - `parent_id`: If trace_id is set, will populate the root span&#39;s parent</span>
<span class="sd">        with this id.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">return</span> <span class="n">traced_impl</span><span class="p">(</span><span class="n">tracer_fn</span><span class="o">=</span><span class="n">tracer</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">trace_id</span><span class="o">=</span><span class="n">trace_id</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="n">parent_id</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">traced_thread</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Function decorator to pass context to a function that is a thread target. Because the beeline uses</span>
<span class="sd">    thread-local storage to keep track of trace state, tracing doesn&#39;t work across threads unless the state</span>
<span class="sd">    is explicitly passed between threads. You can use this decorator to more easily pass state to a thread.</span>

<span class="sd">    Example use:</span>

<span class="sd">    ```</span>
<span class="sd">    @traced(name=&quot;my_async_function&quot;)</span>
<span class="sd">    def my_func():</span>
<span class="sd">        # ...</span>
<span class="sd">        with beeline.tracer(name=&quot;do_stuff&quot;):</span>
<span class="sd">            do_stuff()</span>

<span class="sd">    # we want to call my_func asynchronously by passing to a thread or a thread pool</span>
<span class="sd">    @beeline.traced_thread</span>
<span class="sd">    def _my_func_t():</span>
<span class="sd">        return my_func()</span>

<span class="sd">    t = threading.Thread(target=_my_func_t)</span>
<span class="sd">    t.start()</span>
<span class="sd">    ```</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># if beeline is not initialized, or there is no active trace, do nothing</span>
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">bl</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">get_active_trace_id</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">noop</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">noop</span>

    <span class="n">trace_copy</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">_trace</span> <span class="o">=</span> <span class="n">trace_copy</span>
        <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapped</span>
</pre></div>

  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="beeline.USER_AGENT_ADDITION" class="name">var <span class="ident">USER_AGENT_ADDITION</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="beeline.VERSION" class="name">var <span class="ident">VERSION</span></p>
      
  
  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="beeline.add">
    <p>def <span class="ident">add</span>(</p><p>data)</p>
    </div>
    

    
  
    <div class="desc"><p>DEPRECATED: use <code>add_context</code></p>
<p>Args:
- <code>data</code>: dictionary of field names (strings) to field values to add</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.add', this);">Show source &equiv;</a></p>
  <div id="source-beeline.add" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;DEPRECATED: use `add_context`</span>

<span class="sd">    Args:</span>
<span class="sd">    - `data`: dictionary of field names (strings) to field values to add</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="beeline.add_context">
    <p>def <span class="ident">add_context</span>(</p><p>data)</p>
    </div>
    

    
  
    <div class="desc"><p>Similar to add_context_field(), but allows you to add a number of name:value pairs
to the currently active event at the same time.</p>
<p><code>beeline.add_context({ "first_field": "a", "second_field": "b"})</code></p>
<p>Args:
- <code>data</code>: dictionary of field names (strings) to field values to add</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.add_context', this);">Show source &equiv;</a></p>
  <div id="source-beeline.add_context" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">add_context</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Similar to add_context_field(), but allows you to add a number of name:value pairs</span>
<span class="sd">    to the currently active event at the same time.</span>

<span class="sd">    `beeline.add_context({ &quot;first_field&quot;: &quot;a&quot;, &quot;second_field&quot;: &quot;b&quot;})`</span>

<span class="sd">    Args:</span>
<span class="sd">    - `data`: dictionary of field names (strings) to field values to add</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">add_context</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="beeline.add_context_field">
    <p>def <span class="ident">add_context_field</span>(</p><p>name, value)</p>
    </div>
    

    
  
    <div class="desc"><p>Add a field to the currently active span. For example, if you are
using django and wish to add additional context to the current request
before it is sent to Honeycomb:</p>
<p><code>beeline.add_context_field("my field", "my value")</code></p>
<p>Args:
- <code>name</code>: Name of field to add
- <code>value</code>: Value of new field</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.add_context_field', this);">Show source &equiv;</a></p>
  <div id="source-beeline.add_context_field" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">add_context_field</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Add a field to the currently active span. For example, if you are</span>
<span class="sd">    using django and wish to add additional context to the current request</span>
<span class="sd">    before it is sent to Honeycomb:</span>

<span class="sd">    `beeline.add_context_field(&quot;my field&quot;, &quot;my value&quot;)`</span>

<span class="sd">    Args:</span>
<span class="sd">    - `name`: Name of field to add</span>
<span class="sd">    - `value`: Value of new field</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">add_context_field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="beeline.add_field">
    <p>def <span class="ident">add_field</span>(</p><p>name, value)</p>
    </div>
    

    
  
    <div class="desc"><p>DEPRECATED: use <code>add_context_field</code></p>
<p>Args:
- <code>data</code>: dictionary of field names (strings) to field values to add</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.add_field', this);">Show source &equiv;</a></p>
  <div id="source-beeline.add_field" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">add_field</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; DEPRECATED: use `add_context_field`</span>

<span class="sd">    Args:</span>
<span class="sd">    - `data`: dictionary of field names (strings) to field values to add</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">_GBL</span><span class="p">:</span>
        <span class="n">_GBL</span><span class="o">.</span><span class="n">add_field</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="beeline.add_rollup_field">
    <p>def <span class="ident">add_rollup_field</span>(</p><p>name, value)</p>
    </div>
    

    
  
    <div class="desc"><p>AddRollupField adds a key/value pair to the current span. If it is called repeatedly
on the same span, the values will be summed together.  Additionally, this
field will be summed across all spans and added to the trace as a total. It
is especially useful for doing things like adding the duration spent talking
to a specific external service - eg database time. The root span will then
get a field that represents the total time spent talking to the database from
all of the spans that are part of the trace.</p>
<p>Args:
- <code>name</code>: Name of field to add
- <code>value</code>: Numeric (float) value of new field</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.add_rollup_field', this);">Show source &equiv;</a></p>
  <div id="source-beeline.add_rollup_field" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">add_rollup_field</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; AddRollupField adds a key/value pair to the current span. If it is called repeatedly</span>
<span class="sd">    on the same span, the values will be summed together.  Additionally, this</span>
<span class="sd">    field will be summed across all spans and added to the trace as a total. It</span>
<span class="sd">    is especially useful for doing things like adding the duration spent talking</span>
<span class="sd">    to a specific external service - eg database time. The root span will then</span>
<span class="sd">    get a field that represents the total time spent talking to the database from</span>
<span class="sd">    all of the spans that are part of the trace.</span>

<span class="sd">    Args:</span>
<span class="sd">    - `name`: Name of field to add</span>
<span class="sd">    - `value`: Numeric (float) value of new field</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">add_rollup_field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="beeline.add_trace_field">
    <p>def <span class="ident">add_trace_field</span>(</p><p>name, value)</p>
    </div>
    

    
  
    <div class="desc"><p>Similar to <code>add_context_field</code> - adds a field to the current span, but
also to all other future spans in this trace. Trace context fields will be
propagated to downstream services if using instrumented libraries
like <code>requests</code>.</p>
<p>Args:
- <code>name</code>: Name of field to add
- <code>value</code>: Value of new field</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.add_trace_field', this);">Show source &equiv;</a></p>
  <div id="source-beeline.add_trace_field" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">add_trace_field</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Similar to `add_context_field` - adds a field to the current span, but</span>
<span class="sd">    also to all other future spans in this trace. Trace context fields will be</span>
<span class="sd">    propagated to downstream services if using instrumented libraries</span>
<span class="sd">    like `requests`.</span>

<span class="sd">    Args:</span>
<span class="sd">    - `name`: Name of field to add</span>
<span class="sd">    - `value`: Value of new field</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">add_trace_field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="beeline.close">
    <p>def <span class="ident">close</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>close the beeline and libhoney client, flushing any unsent events.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.close', this);">Show source &equiv;</a></p>
  <div id="source-beeline.close" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">close</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39; close the beeline and libhoney client, flushing any unsent events. &#39;&#39;&#39;</span>
    <span class="k">global</span> <span class="n">_GBL</span>
    <span class="k">if</span> <span class="n">_GBL</span><span class="p">:</span>
        <span class="n">_GBL</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">_GBL</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="beeline.finish_span">
    <p>def <span class="ident">finish_span</span>(</p><p>span)</p>
    </div>
    

    
  
    <div class="desc"><p>Finish the provided span, sending the associated event data to Honeycomb.</p>
<p>For each <code>start_span</code>, there should be one call to <code>finish_span</code>.</p>
<p>Args:
- <code>span</code>: Span object that was returned by <code>start_trace</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.finish_span', this);">Show source &equiv;</a></p>
  <div id="source-beeline.finish_span" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">finish_span</span><span class="p">(</span><span class="n">span</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Finish the provided span, sending the associated event data to Honeycomb.</span>

<span class="sd">    For each `start_span`, there should be one call to `finish_span`.</span>

<span class="sd">    Args:</span>
<span class="sd">    - `span`: Span object that was returned by `start_trace`</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">finish_span</span><span class="p">(</span><span class="n">span</span><span class="o">=</span><span class="n">span</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="beeline.finish_trace">
    <p>def <span class="ident">finish_trace</span>(</p><p>span)</p>
    </div>
    

    
  
    <div class="desc"><p>Explicitly finish a trace. If you started a trace with <code>start_trace</code>, you must call
this to close the trace and send the root span. If you are using the beeline middleware plugins,
such as django, flask, or AWS lambda, you can skip this step as the trace will be closed for
you.</p>
<p>Args:
- <code>span</code>: Span object that was returned by <code>start_trace</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.finish_trace', this);">Show source &equiv;</a></p>
  <div id="source-beeline.finish_trace" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">finish_trace</span><span class="p">(</span><span class="n">span</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Explicitly finish a trace. If you started a trace with `start_trace`, you must call</span>
<span class="sd">    this to close the trace and send the root span. If you are using the beeline middleware plugins,</span>
<span class="sd">    such as django, flask, or AWS lambda, you can skip this step as the trace will be closed for</span>
<span class="sd">    you.</span>

<span class="sd">    Args:</span>
<span class="sd">    - `span`: Span object that was returned by `start_trace`</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">finish_trace</span><span class="p">(</span><span class="n">span</span><span class="o">=</span><span class="n">span</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="beeline.get_beeline">
    <p>def <span class="ident">get_beeline</span>(</p><p>)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.get_beeline', this);">Show source &equiv;</a></p>
  <div id="source-beeline.get_beeline" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get_beeline</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">_GBL</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="beeline.get_responses_queue">
    <p>def <span class="ident">get_responses_queue</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a queue from which you can read a record of response info from
each event sent. Responses will be dicts with the following keys:
    - <code>status_code</code> - the HTTP response from the api (eg. 200 or 503)
    - <code>duration</code> - how long it took to POST this event to the api, in ms
    - <code>metadata</code> - pass through the metadata you added on the initial event
    - <code>body</code> - the content returned by API (will be empty on success)
    - <code>error</code> - in an error condition, this is filled with the error message
When the Client's <code>close</code> method is called, a None will be inserted on
the queue, indicating that no further responses will be written.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.get_responses_queue', this);">Show source &equiv;</a></p>
  <div id="source-beeline.get_responses_queue" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get_responses_queue</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns a queue from which you can read a record of response info from</span>
<span class="sd">    each event sent. Responses will be dicts with the following keys:</span>
<span class="sd">        - `status_code` - the HTTP response from the api (eg. 200 or 503)</span>
<span class="sd">        - `duration` - how long it took to POST this event to the api, in ms</span>
<span class="sd">        - `metadata` - pass through the metadata you added on the initial event</span>
<span class="sd">        - `body` - the content returned by API (will be empty on success)</span>
<span class="sd">        - `error` - in an error condition, this is filled with the error message</span>
<span class="sd">    When the Client&#39;s `close` method is called, a None will be inserted on</span>
<span class="sd">    the queue, indicating that no further responses will be written.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bl</span><span class="o">.</span><span class="n">get_responses_queue</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="beeline.in_async_code">
    <p>def <span class="ident">in_async_code</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Return whether we are running inside an asynchronous task.</p>
<p>We use this information to determine which tracer
implementation to use.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.in_async_code', this);">Show source &equiv;</a></p>
  <div id="source-beeline.in_async_code" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">in_async_code</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return whether we are running inside an asynchronous task.</span>
<span class="sd">    We use this information to determine which tracer</span>
<span class="sd">    implementation to use.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>  <span class="c1"># pylint: disable=no-member</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="beeline.init">
    <p>def <span class="ident">init</span>(</p><p>writekey=&#39;&#39;, dataset=&#39;&#39;, service_name=&#39;&#39;, tracer=None, sample_rate=1, api_host=&#39;https://api.honeycomb.io&#39;, transmission_impl=None, sampler_hook=None, presend_hook=None, debug=False, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>initialize the honeycomb beeline. This will initialize a libhoney
client local to this module, and a tracer to track traces and spans.</p>
<p>Args:
- <code>writekey</code>: the authorization key for your team on Honeycomb. Find your team
        write key at <a href="https://ui.honeycomb.io/account">https://ui.honeycomb.io/account</a>
- <code>dataset</code>: the name of the default dataset to which to write
- <code>sample_rate</code>: the default sample rate. 1 / <code>sample_rate</code> events will be sent.
- <code>transmission_impl</code>: if set, override the default transmission implementation
        (for example, TornadoTransmission)
- <code>sampler_hook</code>: accepts a function to be called just before each event is sent.
        The function should accept a dictionary of event fields, and return a tuple
        of type (bool, int). The first item indicates whether or not the event
        should be sent, and the second indicates the updated sample rate to use.
- <code>presend_hook</code>: accepts a function to be called just before each event is sent.
        The functon should accept a dictionary of event fields, and can be used
        to add new fields, modify/scrub existing fields, or drop fields. This
        function is called after sampler_hook, if sampler_hook is set.</p>
<p>If in doubt, just set <code>writekey</code> and <code>dataset</code> and move on!</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.init', this);">Show source &equiv;</a></p>
  <div id="source-beeline.init" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="n">writekey</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">service_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">tracer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
         <span class="n">sample_rate</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">api_host</span><span class="o">=</span><span class="s1">&#39;https://api.honeycomb.io&#39;</span><span class="p">,</span> <span class="n">transmission_impl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
         <span class="n">sampler_hook</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">presend_hook</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; initialize the honeycomb beeline. This will initialize a libhoney</span>
<span class="sd">    client local to this module, and a tracer to track traces and spans.</span>

<span class="sd">    Args:</span>
<span class="sd">    - `writekey`: the authorization key for your team on Honeycomb. Find your team</span>
<span class="sd">            write key at [https://ui.honeycomb.io/account](https://ui.honeycomb.io/account)</span>
<span class="sd">    - `dataset`: the name of the default dataset to which to write</span>
<span class="sd">    - `sample_rate`: the default sample rate. 1 / `sample_rate` events will be sent.</span>
<span class="sd">    - `transmission_impl`: if set, override the default transmission implementation</span>
<span class="sd">            (for example, TornadoTransmission)</span>
<span class="sd">    - `sampler_hook`: accepts a function to be called just before each event is sent.</span>
<span class="sd">            The function should accept a dictionary of event fields, and return a tuple</span>
<span class="sd">            of type (bool, int). The first item indicates whether or not the event</span>
<span class="sd">            should be sent, and the second indicates the updated sample rate to use.</span>
<span class="sd">    - `presend_hook`: accepts a function to be called just before each event is sent.</span>
<span class="sd">            The functon should accept a dictionary of event fields, and can be used</span>
<span class="sd">            to add new fields, modify/scrub existing fields, or drop fields. This</span>
<span class="sd">            function is called after sampler_hook, if sampler_hook is set.</span>

<span class="sd">    If in doubt, just set `writekey` and `dataset` and move on!</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">global</span> <span class="n">_GBL</span>
    <span class="k">global</span> <span class="n">_INITPID</span>
    <span class="n">pid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">_GBL</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">pid</span> <span class="o">==</span> <span class="n">_INITPID</span><span class="p">:</span>
            <span class="n">_GBL</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;beeline already initialized! skipping initialization&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">_GBL</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;beeline already initialized, but process ID has changed (was </span><span class="si">{}</span><span class="s2">, now </span><span class="si">{}</span><span class="s2">). Reinitializing.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_INITPID</span><span class="p">,</span> <span class="n">pid</span><span class="p">))</span>
        <span class="n">_GBL</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">_GBL</span> <span class="o">=</span> <span class="n">Beeline</span><span class="p">(</span>
        <span class="n">writekey</span><span class="o">=</span><span class="n">writekey</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span>
        <span class="n">api_host</span><span class="o">=</span><span class="n">api_host</span><span class="p">,</span> <span class="n">transmission_impl</span><span class="o">=</span><span class="n">transmission_impl</span><span class="p">,</span>
        <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">presend_hook</span><span class="o">=</span><span class="n">presend_hook</span><span class="p">,</span> <span class="n">sampler_hook</span><span class="o">=</span><span class="n">sampler_hook</span><span class="p">,</span>
        <span class="n">service_name</span><span class="o">=</span><span class="n">service_name</span><span class="p">,</span>
        <span class="c1"># since we&#39;ve simplified the init function signature a bit,</span>
        <span class="c1"># pass on other args for backwards compatibility</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>
    <span class="c1"># Store the PID that initialized the beeline globally. If the beeline was initialized in another</span>
    <span class="c1"># process that was later forked, we can use this to detect it and reinitialize the client (and the transmission</span>
    <span class="c1"># thread).</span>
    <span class="n">_INITPID</span> <span class="o">=</span> <span class="n">pid</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="beeline.marshal_trace_context">
    <p>def <span class="ident">marshal_trace_context</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a serialized form of the current trace context (including the trace
id and the current span), encoded as a string. You can use this to propagate
trace context to other services.</p>
<p>Example:</p>
<p><code>trace_context = beeline.marshal_trace_context()
headers = {'X-Honeycomb-Trace': trace_context}
requests.get("http://...", headers=headers)</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.marshal_trace_context', this);">Show source &equiv;</a></p>
  <div id="source-beeline.marshal_trace_context" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">marshal_trace_context</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns a serialized form of the current trace context (including the trace</span>
<span class="sd">    id and the current span), encoded as a string. You can use this to propagate</span>
<span class="sd">    trace context to other services.</span>

<span class="sd">    Example:</span>

<span class="sd">    ```</span>
<span class="sd">    trace_context = beeline.marshal_trace_context()</span>
<span class="sd">    headers = {&#39;X-Honeycomb-Trace&#39;: trace_context}</span>
<span class="sd">    requests.get(&quot;http://...&quot;, headers=headers)</span>
<span class="sd">    ```</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">marshal_trace_context</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="beeline.new_event">
    <p>def <span class="ident">new_event</span>(</p><p>data=None, trace_name=&#39;&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>DEPRECATED: Helper method that wraps <code>start_trace</code> and
<code>start_span</code>. It is better to use these methods as it provides
better control and context around how traces are implemented in your
app.</p>
<p>Creates a new span, populating it with the given data if
supplied. If no trace is running, a new trace will be started,
otherwise the event will be added as a span of the existing trace.</p>
<p>To send the event, call <code>beeline.send_event()</code>. There should be a
<code>send_event()</code> for each call to <code>new_event()</code>, or tracing and
<code>add</code> and <code>add_field</code> will not work correctly.</p>
<p>If trace_name is specified, will set the "name" field of the current span,
which is used in the trace visualizer.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.new_event', this);">Show source &equiv;</a></p>
  <div id="source-beeline.new_event" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">new_event</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">trace_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; DEPRECATED: Helper method that wraps `start_trace` and</span>
<span class="sd">    `start_span`. It is better to use these methods as it provides</span>
<span class="sd">    better control and context around how traces are implemented in your</span>
<span class="sd">    app.</span>

<span class="sd">    Creates a new span, populating it with the given data if</span>
<span class="sd">    supplied. If no trace is running, a new trace will be started,</span>
<span class="sd">    otherwise the event will be added as a span of the existing trace.</span>

<span class="sd">    To send the event, call `beeline.send_event()`. There should be a</span>
<span class="sd">    `send_event()` for each call to `new_event()`, or tracing and</span>
<span class="sd">    `add` and `add_field` will not work correctly.</span>

<span class="sd">    If trace_name is specified, will set the &quot;name&quot; field of the current span,</span>
<span class="sd">    which is used in the trace visualizer.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">new_event</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">trace_name</span><span class="o">=</span><span class="n">trace_name</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="beeline.remove_context_field">
    <p>def <span class="ident">remove_context_field</span>(</p><p>name)</p>
    </div>
    

    
  
    <div class="desc"><p>Remove a single field from the current span.</p>
<p>```
beeline.add_context({ "first_field": "a", "second_field": "b"})
beeline.remove_context_field("second_field")</p>
<p>Args:
- <code>name</code>: Name of field to remove
```</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.remove_context_field', this);">Show source &equiv;</a></p>
  <div id="source-beeline.remove_context_field" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">remove_context_field</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Remove a single field from the current span.</span>

<span class="sd">    ```</span>
<span class="sd">    beeline.add_context({ &quot;first_field&quot;: &quot;a&quot;, &quot;second_field&quot;: &quot;b&quot;})</span>
<span class="sd">    beeline.remove_context_field(&quot;second_field&quot;)</span>

<span class="sd">    Args:</span>
<span class="sd">    - `name`: Name of field to remove</span>
<span class="sd">    ```</span>
<span class="sd">     &#39;&#39;&#39;</span>
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">remove_context_field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="beeline.remove_trace_field">
    <p>def <span class="ident">remove_trace_field</span>(</p><p>name)</p>
    </div>
    

    
  
    <div class="desc"><p>Removes a trace context field from the current span. This will not
affect  other existing spans, but will prevent the field from being
propagated to new spans.</p>
<p>Args:
- <code>name</code>: Name of field to remove</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.remove_trace_field', this);">Show source &equiv;</a></p>
  <div id="source-beeline.remove_trace_field" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">remove_trace_field</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Removes a trace context field from the current span. This will not</span>
<span class="sd">    affect  other existing spans, but will prevent the field from being</span>
<span class="sd">    propagated to new spans.</span>

<span class="sd">    Args:</span>
<span class="sd">    - `name`: Name of field to remove</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">remove_trace_field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="beeline.send_all">
    <p>def <span class="ident">send_all</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>send all spans in the trace stack, regardless of their
state. You might use this in a catch-all error handler
along with <code>beeline.close()</code> to send all events before the program
terminates abruptly.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.send_all', this);">Show source &equiv;</a></p>
  <div id="source-beeline.send_all" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">send_all</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39; send all spans in the trace stack, regardless of their</span>
<span class="sd">    state. You might use this in a catch-all error handler</span>
<span class="sd">    along with `beeline.close()` to send all events before the program</span>
<span class="sd">    terminates abruptly.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">send_all</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="beeline.send_event">
    <p>def <span class="ident">send_event</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>DEPRECATED: Sends the currently active event (current span),
if it exists.</p>
<p>There must be one call to <code>send_event</code> for each call to <code>new_event</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.send_event', this);">Show source &equiv;</a></p>
  <div id="source-beeline.send_event" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">send_event</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39; DEPRECATED: Sends the currently active event (current span),</span>
<span class="sd">    if it exists.</span>

<span class="sd">    There must be one call to `send_event` for each call to `new_event`.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">send_event</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="beeline.send_now">
    <p>def <span class="ident">send_now</span>(</p><p>data)</p>
    </div>
    

    
  
    <div class="desc"><p>Create an event and enqueue it immediately. Does not work with
<a href="#beeline.add_field"><code>add_field</code></a> - this is equivalent to calling <code>libhoney.send_now</code></p>
<p>Args:
- <code>data</code>: dictionary of field names (strings) to field values to include
          in the event</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.send_now', this);">Show source &equiv;</a></p>
  <div id="source-beeline.send_now" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">send_now</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Create an event and enqueue it immediately. Does not work with</span>
<span class="sd">    `beeline.add_field` - this is equivalent to calling `libhoney.send_now`</span>

<span class="sd">    Args:</span>
<span class="sd">    - `data`: dictionary of field names (strings) to field values to include</span>
<span class="sd">              in the event</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># no-op if we&#39;re not initialized</span>
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">send_now</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="beeline.start_span">
    <p>def <span class="ident">start_span</span>(</p><p>context=None, parent_id=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Start a new span and return the span object. Returns None if no trace is active.
For each <code>start_span</code>, there should be one call to <code>close_span</code>. Child spans should
also be closed before parent spans. Closing spans out of order will lead to strange
results and can break the bookkeeping needed to preserve trace structure. For example:</p>
<p>```
parent_span = beeline.start_span()</p>
<h1>this span is a child of the last span created</h1>
<p>child_span = beeline.start_span()
beeline.finish_span(child_span)
beeline.finish_span(parent_span)
```</p>
<p>Args:
- <code>context</code>: optional dictionary of event fields to populate the span with
- <code>parent_id</code>: ID of parent span - use this only if you have a very good reason to
    do so.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.start_span', this);">Show source &equiv;</a></p>
  <div id="source-beeline.start_span" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">start_span</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Start a new span and return the span object. Returns None if no trace is active.</span>
<span class="sd">    For each `start_span`, there should be one call to `close_span`. Child spans should</span>
<span class="sd">    also be closed before parent spans. Closing spans out of order will lead to strange</span>
<span class="sd">    results and can break the bookkeeping needed to preserve trace structure. For example:</span>

<span class="sd">    ```</span>
<span class="sd">    parent_span = beeline.start_span()</span>
<span class="sd">    # this span is a child of the last span created</span>
<span class="sd">    child_span = beeline.start_span()</span>
<span class="sd">    beeline.finish_span(child_span)</span>
<span class="sd">    beeline.finish_span(parent_span)</span>
<span class="sd">    ```</span>

<span class="sd">    Args:</span>
<span class="sd">    - `context`: optional dictionary of event fields to populate the span with</span>
<span class="sd">    - `parent_id`: ID of parent span - use this only if you have a very good reason to</span>
<span class="sd">        do so.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">start_span</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="n">parent_id</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="beeline.start_trace">
    <p>def <span class="ident">start_trace</span>(</p><p>context=None, trace_id=None, parent_span_id=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Start a trace, returning the root span. To finish the trace, pass the span
to <code>finish_trace</code>. If you are using the beeline middleware plugins, such as for
django, flask, or AWS lambda, you will want to use <code>start_span</code> instead, as
<code>start_trace</code> is called at the start of the request.</p>
<p>Args:
- <code>context</code>: optional dictionary of event fields to populate the root span with
- <code>trace_id</code>: the trace_id to use. If None, will be automatically generated.
    Use this if you want to explicitly resume trace in this application that was
    initiated in another application, and you have the upstream trace_id.
- <code>parent_span_id</code>: If trace_id is set, will populate the root span's parent
    with this id.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.start_trace', this);">Show source &equiv;</a></p>
  <div id="source-beeline.start_trace" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">start_trace</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">trace_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent_span_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Start a trace, returning the root span. To finish the trace, pass the span</span>
<span class="sd">    to `finish_trace`. If you are using the beeline middleware plugins, such as for</span>
<span class="sd">    django, flask, or AWS lambda, you will want to use `start_span` instead, as</span>
<span class="sd">    `start_trace` is called at the start of the request.</span>

<span class="sd">    Args:</span>
<span class="sd">    - `context`: optional dictionary of event fields to populate the root span with</span>
<span class="sd">    - `trace_id`: the trace_id to use. If None, will be automatically generated.</span>
<span class="sd">        Use this if you want to explicitly resume trace in this application that was</span>
<span class="sd">        initiated in another application, and you have the upstream trace_id.</span>
<span class="sd">    - `parent_span_id`: If trace_id is set, will populate the root span&#39;s parent</span>
<span class="sd">        with this id.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">start_trace</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">,</span> <span class="n">trace_id</span><span class="o">=</span><span class="n">trace_id</span><span class="p">,</span> <span class="n">parent_span_id</span><span class="o">=</span><span class="n">parent_span_id</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="beeline.traced">
    <p>def <span class="ident">traced</span>(</p><p>name, trace_id=None, parent_id=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Function decorator to wrap an entire function in a trace span. If no trace
is active in the current thread, starts a new trace, and the wrapping span
will be a root span. If a trace is active, creates a child span of the
existing trace.</p>
<p>Example use:</p>
<p>```
@traced(name="my_expensive_function")
def my_func(n):
    recursive_fib(n)</p>
<p>my_func(100)
```</p>
<p>Args:
- <code>name</code>: a descriptive name for the this trace span, i.e. "function_name". This is required.
- <code>trace_id</code>: the trace_id to use. If None, will be automatically generated.
    Use this if you want to explicitly resume a trace in this application that was
    initiated in another application, and you have the upstream trace_id.
- <code>parent_id</code>: If trace_id is set, will populate the root span's parent
    with this id.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.traced', this);">Show source &equiv;</a></p>
  <div id="source-beeline.traced" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">traced</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">trace_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Function decorator to wrap an entire function in a trace span. If no trace</span>
<span class="sd">    is active in the current thread, starts a new trace, and the wrapping span</span>
<span class="sd">    will be a root span. If a trace is active, creates a child span of the</span>
<span class="sd">    existing trace.</span>

<span class="sd">    Example use:</span>

<span class="sd">    ```</span>
<span class="sd">    @traced(name=&quot;my_expensive_function&quot;)</span>
<span class="sd">    def my_func(n):</span>
<span class="sd">        recursive_fib(n)</span>

<span class="sd">    my_func(100)</span>
<span class="sd">    ```</span>

<span class="sd">    Args:</span>
<span class="sd">    - `name`: a descriptive name for the this trace span, i.e. &quot;function_name&quot;. This is required.</span>
<span class="sd">    - `trace_id`: the trace_id to use. If None, will be automatically generated.</span>
<span class="sd">        Use this if you want to explicitly resume a trace in this application that was</span>
<span class="sd">        initiated in another application, and you have the upstream trace_id.</span>
<span class="sd">    - `parent_id`: If trace_id is set, will populate the root span&#39;s parent</span>
<span class="sd">        with this id.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">return</span> <span class="n">traced_impl</span><span class="p">(</span><span class="n">tracer_fn</span><span class="o">=</span><span class="n">tracer</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">trace_id</span><span class="o">=</span><span class="n">trace_id</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="n">parent_id</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="beeline.traced_thread">
    <p>def <span class="ident">traced_thread</span>(</p><p>fn)</p>
    </div>
    

    
  
    <div class="desc"><p>Function decorator to pass context to a function that is a thread target. Because the beeline uses
thread-local storage to keep track of trace state, tracing doesn't work across threads unless the state
is explicitly passed between threads. You can use this decorator to more easily pass state to a thread.</p>
<p>Example use:</p>
<p>```
@traced(name="my_async_function")
def my_func():
    # ...
    with beeline.tracer(name="do_stuff"):
        do_stuff()</p>
<h1>we want to call my_func asynchronously by passing to a thread or a thread pool</h1>
<p>@beeline.traced_thread
def _my_func_t():
    return my_func()</p>
<p>t = threading.Thread(target=_my_func_t)
t.start()
```</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.traced_thread', this);">Show source &equiv;</a></p>
  <div id="source-beeline.traced_thread" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">traced_thread</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Function decorator to pass context to a function that is a thread target. Because the beeline uses</span>
<span class="sd">    thread-local storage to keep track of trace state, tracing doesn&#39;t work across threads unless the state</span>
<span class="sd">    is explicitly passed between threads. You can use this decorator to more easily pass state to a thread.</span>

<span class="sd">    Example use:</span>

<span class="sd">    ```</span>
<span class="sd">    @traced(name=&quot;my_async_function&quot;)</span>
<span class="sd">    def my_func():</span>
<span class="sd">        # ...</span>
<span class="sd">        with beeline.tracer(name=&quot;do_stuff&quot;):</span>
<span class="sd">            do_stuff()</span>

<span class="sd">    # we want to call my_func asynchronously by passing to a thread or a thread pool</span>
<span class="sd">    @beeline.traced_thread</span>
<span class="sd">    def _my_func_t():</span>
<span class="sd">        return my_func()</span>

<span class="sd">    t = threading.Thread(target=_my_func_t)</span>
<span class="sd">    t.start()</span>
<span class="sd">    ```</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># if beeline is not initialized, or there is no active trace, do nothing</span>
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">bl</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">get_active_trace_id</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">noop</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">noop</span>

    <span class="n">trace_copy</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">bl</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">_trace</span> <span class="o">=</span> <span class="n">trace_copy</span>
        <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapped</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="beeline.tracer">
    <p>def <span class="ident">tracer</span>(</p><p>name, trace_id=None, parent_id=None)</p>
    </div>
    

    
  
    <div class="desc"><p>When used in a context manager, creates a span for the contained
code. If a trace is ongoing, will add a new child span under the currently
running span. If no trace is ongoing, will start a new trace.</p>
<p>Example use:</p>
<p><code>with tracer(name="my expensive computation"):
    recursive_fib(100)</code></p>
<p>Args:
- <code>name</code>: a descriptive name for the this trace span, i.e. "database query for user"
- <code>trace_id</code>: the trace_id to use. If None, will be automatically generated if no
   current trace is ongoing. Use this if you want to explicitly resume a trace
   in this application that was initiated in another application, and you have
   the upstream trace_id.
- <code>parent_id</code>: If trace_id is set, will populate the root span's parent
    with this id.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.tracer', this);">Show source &equiv;</a></p>
  <div id="source-beeline.tracer" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">tracer</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">trace_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    When used in a context manager, creates a span for the contained</span>
<span class="sd">    code. If a trace is ongoing, will add a new child span under the currently</span>
<span class="sd">    running span. If no trace is ongoing, will start a new trace.</span>

<span class="sd">    Example use:</span>

<span class="sd">    ```</span>
<span class="sd">    with tracer(name=&quot;my expensive computation&quot;):</span>
<span class="sd">        recursive_fib(100)</span>
<span class="sd">    ```</span>

<span class="sd">    Args:</span>
<span class="sd">    - `name`: a descriptive name for the this trace span, i.e. &quot;database query for user&quot;</span>
<span class="sd">    - `trace_id`: the trace_id to use. If None, will be automatically generated if no</span>
<span class="sd">       current trace is ongoing. Use this if you want to explicitly resume a trace</span>
<span class="sd">       in this application that was initiated in another application, and you have</span>
<span class="sd">       the upstream trace_id.</span>
<span class="sd">    - `parent_id`: If trace_id is set, will populate the root span&#39;s parent</span>
<span class="sd">        with this id.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">bl</span> <span class="o">=</span> <span class="n">get_beeline</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">bl</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bl</span><span class="o">.</span><span class="n">tracer</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">trace_id</span><span class="o">=</span><span class="n">trace_id</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="n">parent_id</span><span class="p">)</span>

    <span class="c1"># if the beeline is not initialized, build a dummy function</span>
    <span class="c1"># that will work as a context manager and call that</span>
    <span class="nd">@contextmanager</span>
    <span class="k">def</span> <span class="nf">_noop_cm</span><span class="p">():</span>
        <span class="k">yield</span>

    <span class="k">return</span> <span class="n">_noop_cm</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="beeline.Beeline" class="name">class <span class="ident">Beeline</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.Beeline', this);">Show source &equiv;</a></p>
  <div id="source-beeline.Beeline" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Beeline</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">writekey</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">service_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
            <span class="n">tracer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">api_host</span><span class="o">=</span><span class="s1">&#39;https://api.honeycomb.io&#39;</span><span class="p">,</span>
            <span class="n">max_concurrent_batches</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_batch_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">send_frequency</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
            <span class="n">block_on_send</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">block_on_response</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">transmission_impl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sampler_hook</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">presend_hook</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">client</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">presend_hook</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler_hook</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">debug</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_logger</span><span class="p">()</span>

        <span class="c1"># allow setting some values from the environment</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">writekey</span><span class="p">:</span>
            <span class="n">writekey</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;HONEYCOMB_WRITEKEY&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">dataset</span><span class="p">:</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;HONEYCOMB_DATASET&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">service_name</span><span class="p">:</span>
            <span class="n">service_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;HONEYCOMB_SERVICE&#39;</span><span class="p">,</span> <span class="n">dataset</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span>
            <span class="n">writekey</span><span class="o">=</span><span class="n">writekey</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span>
            <span class="n">api_host</span><span class="o">=</span><span class="n">api_host</span><span class="p">,</span> <span class="n">max_concurrent_batches</span><span class="o">=</span><span class="n">max_concurrent_batches</span><span class="p">,</span>
            <span class="n">max_batch_size</span><span class="o">=</span><span class="n">max_batch_size</span><span class="p">,</span> <span class="n">send_frequency</span><span class="o">=</span><span class="n">send_frequency</span><span class="p">,</span>
            <span class="n">block_on_send</span><span class="o">=</span><span class="n">block_on_send</span><span class="p">,</span> <span class="n">block_on_response</span><span class="o">=</span><span class="n">block_on_response</span><span class="p">,</span>
            <span class="n">transmission_impl</span><span class="o">=</span><span class="n">transmission_impl</span><span class="p">,</span>
            <span class="n">user_agent_addition</span><span class="o">=</span><span class="n">USER_AGENT_ADDITION</span><span class="p">,</span>
            <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;initialized honeycomb client: writekey=</span><span class="si">%s</span><span class="s1"> dataset=</span><span class="si">%s</span><span class="s1"> service_name=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                   <span class="n">writekey</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">service_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">writekey</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;writekey not set! set the writekey if you want to send data to honeycomb&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dataset</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;dataset not set! set a value for dataset if you want to send data to honeycomb&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">add_field</span><span class="p">(</span><span class="s1">&#39;service_name&#39;</span><span class="p">,</span> <span class="n">service_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">add_field</span><span class="p">(</span><span class="s1">&#39;meta.beeline_version&#39;</span><span class="p">,</span> <span class="n">VERSION</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">add_field</span><span class="p">(</span><span class="s1">&#39;meta.local_hostname&#39;</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">gethostname</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">in_async_code</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span> <span class="o">=</span> <span class="n">AsyncioTracer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span> <span class="o">=</span> <span class="n">SynchronousTracer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">register_hooks</span><span class="p">(</span><span class="n">presend</span><span class="o">=</span><span class="n">presend_hook</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="n">sampler_hook</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler_hook</span> <span class="o">=</span> <span class="n">sampler_hook</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">presend_hook</span> <span class="o">=</span> <span class="n">presend_hook</span>

    <span class="k">def</span> <span class="nf">send_now</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; DEPRECATED - to be removed in a future release</span>

<span class="sd">        Create an event and enqueue it immediately. Does not work with</span>
<span class="sd">        `beeline.add_field` - this is equivalent to calling `libhoney.send_now`</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">new_event</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">ev</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_run_hooks_and_send</span><span class="p">(</span><span class="n">ev</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Add a field to the currently active span.</span>

<span class="sd">        `beeline.add_field(&quot;my field&quot;, &quot;my value&quot;)`</span>

<span class="sd">        If a field is being attributed to the wrong span/event,</span>
<span class="sd">        make sure that `new_event` and `close_event` calls are matched.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># fetch the current event from our tracer</span>
        <span class="n">span</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">get_active_span</span><span class="p">()</span>
        <span class="c1"># if there are no spans, this is a noop</span>
        <span class="k">if</span> <span class="n">span</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">span</span><span class="o">.</span><span class="n">add_context_field</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Similar to add_field(), but allows you to add a number of name:value pairs</span>
<span class="sd">        to the currently active event at the same time.</span>

<span class="sd">        `beeline.add({ &quot;first_field&quot;: &quot;a&quot;, &quot;second_field&quot;: &quot;b&quot;})`</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># fetch the current event from the tracer</span>
        <span class="n">span</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">get_active_span</span><span class="p">()</span>
        <span class="c1"># if there are no spans, this is a noop</span>
        <span class="k">if</span> <span class="n">span</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">span</span><span class="o">.</span><span class="n">add_context</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">trace_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">trace_id</span><span class="o">=</span><span class="n">trace_id</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="n">parent_id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">new_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">trace_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; DEPRECATED: Helper method that wraps `start_trace` and</span>
<span class="sd">        `start_span`. It is better to use these methods as it provides</span>
<span class="sd">        better control and context around how traces are implemented in your</span>
<span class="sd">        app.</span>

<span class="sd">        Creates a new span, populating it with the given data if</span>
<span class="sd">        supplied. If no trace is running, a new trace will be started,</span>
<span class="sd">        otherwise the event will be added as a span of the existing trace.</span>

<span class="sd">        To send the event, call `beeline.send_event()`. There should be a</span>
<span class="sd">        `send_event()` for each call to `new_event()`, or tracing and</span>
<span class="sd">        `add` and `add_field` will not work correctly.</span>

<span class="sd">        If trace_name is specified, will set the &quot;name&quot; field of the current span,</span>
<span class="sd">        which is used in the trace visualizer.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">trace_name</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trace_name</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">get_active_trace_id</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">start_span</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">start_trace</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">send_event</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; DEPRECATED: Sends the currently active event (current span),</span>
<span class="sd">        if it exists.</span>

<span class="sd">        There must be one call to `send_event` for each call to `new_event`.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">span</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">get_active_span</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">span</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">span</span><span class="o">.</span><span class="n">is_root</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">finish_trace</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">finish_span</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">send_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; send all spans in the trace stack, regardless of their</span>
<span class="sd">        state</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">span</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">get_active_span</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">span</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">span</span><span class="o">.</span><span class="n">is_root</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">finish_trace</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">finish_span</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>
            <span class="n">span</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">get_active_span</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">traced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">trace_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">traced_impl</span><span class="p">(</span><span class="n">tracer_fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tracer</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">trace_id</span><span class="o">=</span><span class="n">trace_id</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="n">parent_id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">traced_thread</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
        <span class="n">trace_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">_trace</span> <span class="o">=</span> <span class="n">trace_copy</span>
            <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">wrapped</span>

    <span class="k">def</span> <span class="nf">_run_hooks_and_send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ev</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; internal - run any defined hooks on the event and send &#39;&#39;&#39;</span>
        <span class="n">presampled</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler_hook</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;executing sampler hook on event ev = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ev</span><span class="o">.</span><span class="n">fields</span><span class="p">())</span>
            <span class="n">keep</span><span class="p">,</span> <span class="n">new_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler_hook</span><span class="p">(</span><span class="n">ev</span><span class="o">.</span><span class="n">fields</span><span class="p">())</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">keep</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;skipping event due to sampler hook sampling ev = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ev</span><span class="o">.</span><span class="n">fields</span><span class="p">())</span>
                <span class="k">return</span>
            <span class="n">ev</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="n">new_rate</span>
            <span class="n">presampled</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">presend_hook</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;executing presend hook on event ev = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ev</span><span class="o">.</span><span class="n">fields</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">presend_hook</span><span class="p">(</span><span class="n">ev</span><span class="o">.</span><span class="n">fields</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">presampled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;enqueuing presampled event ev = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ev</span><span class="o">.</span><span class="n">fields</span><span class="p">())</span>
            <span class="n">ev</span><span class="o">.</span><span class="n">send_presampled</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;enqueuing event ev = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ev</span><span class="o">.</span><span class="n">fields</span><span class="p">())</span>
            <span class="n">ev</span><span class="o">.</span><span class="n">send</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_init_logger</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;honeycomb-beeline&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">()</span>
        <span class="n">ch</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
        <span class="n">formatter</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%(asctime)s</span><span class="s1"> - </span><span class="si">%(name)s</span><span class="s1"> - </span><span class="si">%(levelname)s</span><span class="s1"> - </span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">ch</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_responses_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">responses</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#beeline.Beeline">Beeline</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="beeline.Beeline.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, writekey=&#39;&#39;, dataset=&#39;&#39;, service_name=&#39;&#39;, tracer=None, sample_rate=1, api_host=&#39;https://api.honeycomb.io&#39;, max_concurrent_batches=10, max_batch_size=100, send_frequency=0.25, block_on_send=False, block_on_response=False, transmission_impl=None, sampler_hook=None, presend_hook=None, debug=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.Beeline.__init__', this);">Show source &equiv;</a></p>
  <div id="source-beeline.Beeline.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
        <span class="n">writekey</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">service_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="n">tracer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">api_host</span><span class="o">=</span><span class="s1">&#39;https://api.honeycomb.io&#39;</span><span class="p">,</span>
        <span class="n">max_concurrent_batches</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_batch_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">send_frequency</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
        <span class="n">block_on_send</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">block_on_response</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">transmission_impl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sampler_hook</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">presend_hook</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">client</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">presend_hook</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">sampler_hook</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">debug</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_logger</span><span class="p">()</span>
    <span class="c1"># allow setting some values from the environment</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">writekey</span><span class="p">:</span>
        <span class="n">writekey</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;HONEYCOMB_WRITEKEY&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dataset</span><span class="p">:</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;HONEYCOMB_DATASET&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">service_name</span><span class="p">:</span>
        <span class="n">service_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;HONEYCOMB_SERVICE&#39;</span><span class="p">,</span> <span class="n">dataset</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span>
        <span class="n">writekey</span><span class="o">=</span><span class="n">writekey</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span>
        <span class="n">api_host</span><span class="o">=</span><span class="n">api_host</span><span class="p">,</span> <span class="n">max_concurrent_batches</span><span class="o">=</span><span class="n">max_concurrent_batches</span><span class="p">,</span>
        <span class="n">max_batch_size</span><span class="o">=</span><span class="n">max_batch_size</span><span class="p">,</span> <span class="n">send_frequency</span><span class="o">=</span><span class="n">send_frequency</span><span class="p">,</span>
        <span class="n">block_on_send</span><span class="o">=</span><span class="n">block_on_send</span><span class="p">,</span> <span class="n">block_on_response</span><span class="o">=</span><span class="n">block_on_response</span><span class="p">,</span>
        <span class="n">transmission_impl</span><span class="o">=</span><span class="n">transmission_impl</span><span class="p">,</span>
        <span class="n">user_agent_addition</span><span class="o">=</span><span class="n">USER_AGENT_ADDITION</span><span class="p">,</span>
        <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;initialized honeycomb client: writekey=</span><span class="si">%s</span><span class="s1"> dataset=</span><span class="si">%s</span><span class="s1"> service_name=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
               <span class="n">writekey</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">service_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">writekey</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;writekey not set! set the writekey if you want to send data to honeycomb&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dataset</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;dataset not set! set a value for dataset if you want to send data to honeycomb&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">add_field</span><span class="p">(</span><span class="s1">&#39;service_name&#39;</span><span class="p">,</span> <span class="n">service_name</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">add_field</span><span class="p">(</span><span class="s1">&#39;meta.beeline_version&#39;</span><span class="p">,</span> <span class="n">VERSION</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">add_field</span><span class="p">(</span><span class="s1">&#39;meta.local_hostname&#39;</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">gethostname</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">in_async_code</span><span class="p">():</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span> <span class="o">=</span> <span class="n">AsyncioTracer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span> <span class="o">=</span> <span class="n">SynchronousTracer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">register_hooks</span><span class="p">(</span><span class="n">presend</span><span class="o">=</span><span class="n">presend_hook</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="n">sampler_hook</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">sampler_hook</span> <span class="o">=</span> <span class="n">sampler_hook</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">presend_hook</span> <span class="o">=</span> <span class="n">presend_hook</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="beeline.Beeline.add">
    <p>def <span class="ident">add</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Similar to add_field(), but allows you to add a number of name:value pairs
to the currently active event at the same time.</p>
<p><code>beeline.add({ "first_field": "a", "second_field": "b"})</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.Beeline.add', this);">Show source &equiv;</a></p>
  <div id="source-beeline.Beeline.add" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Similar to add_field(), but allows you to add a number of name:value pairs</span>
<span class="sd">    to the currently active event at the same time.</span>
<span class="sd">    `beeline.add({ &quot;first_field&quot;: &quot;a&quot;, &quot;second_field&quot;: &quot;b&quot;})`</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># fetch the current event from the tracer</span>
    <span class="n">span</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">get_active_span</span><span class="p">()</span>
    <span class="c1"># if there are no spans, this is a noop</span>
    <span class="k">if</span> <span class="n">span</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">span</span><span class="o">.</span><span class="n">add_context</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="beeline.Beeline.add_field">
    <p>def <span class="ident">add_field</span>(</p><p>self, name, value)</p>
    </div>
    

    
  
    <div class="desc"><p>Add a field to the currently active span.</p>
<p><code>beeline.add_field("my field", "my value")</code></p>
<p>If a field is being attributed to the wrong span/event,
make sure that <code>new_event</code> and <code>close_event</code> calls are matched.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.Beeline.add_field', this);">Show source &equiv;</a></p>
  <div id="source-beeline.Beeline.add_field" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">add_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Add a field to the currently active span.</span>
<span class="sd">    `beeline.add_field(&quot;my field&quot;, &quot;my value&quot;)`</span>
<span class="sd">    If a field is being attributed to the wrong span/event,</span>
<span class="sd">    make sure that `new_event` and `close_event` calls are matched.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># fetch the current event from our tracer</span>
    <span class="n">span</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">get_active_span</span><span class="p">()</span>
    <span class="c1"># if there are no spans, this is a noop</span>
    <span class="k">if</span> <span class="n">span</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">span</span><span class="o">.</span><span class="n">add_context_field</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="beeline.Beeline.close">
    <p>def <span class="ident">close</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.Beeline.close', this);">Show source &equiv;</a></p>
  <div id="source-beeline.Beeline.close" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="beeline.Beeline.get_responses_queue">
    <p>def <span class="ident">get_responses_queue</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.Beeline.get_responses_queue', this);">Show source &equiv;</a></p>
  <div id="source-beeline.Beeline.get_responses_queue" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get_responses_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">responses</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="beeline.Beeline.log">
    <p>def <span class="ident">log</span>(</p><p>self, msg, *args, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.Beeline.log', this);">Show source &equiv;</a></p>
  <div id="source-beeline.Beeline.log" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="beeline.Beeline.new_event">
    <p>def <span class="ident">new_event</span>(</p><p>self, data=None, trace_name=&#39;&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>DEPRECATED: Helper method that wraps <code>start_trace</code> and
<code>start_span</code>. It is better to use these methods as it provides
better control and context around how traces are implemented in your
app.</p>
<p>Creates a new span, populating it with the given data if
supplied. If no trace is running, a new trace will be started,
otherwise the event will be added as a span of the existing trace.</p>
<p>To send the event, call <code>beeline.send_event()</code>. There should be a
<code>send_event()</code> for each call to <code>new_event()</code>, or tracing and
<code>add</code> and <code>add_field</code> will not work correctly.</p>
<p>If trace_name is specified, will set the "name" field of the current span,
which is used in the trace visualizer.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.Beeline.new_event', this);">Show source &equiv;</a></p>
  <div id="source-beeline.Beeline.new_event" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">new_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">trace_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; DEPRECATED: Helper method that wraps `start_trace` and</span>
<span class="sd">    `start_span`. It is better to use these methods as it provides</span>
<span class="sd">    better control and context around how traces are implemented in your</span>
<span class="sd">    app.</span>
<span class="sd">    Creates a new span, populating it with the given data if</span>
<span class="sd">    supplied. If no trace is running, a new trace will be started,</span>
<span class="sd">    otherwise the event will be added as a span of the existing trace.</span>
<span class="sd">    To send the event, call `beeline.send_event()`. There should be a</span>
<span class="sd">    `send_event()` for each call to `new_event()`, or tracing and</span>
<span class="sd">    `add` and `add_field` will not work correctly.</span>
<span class="sd">    If trace_name is specified, will set the &quot;name&quot; field of the current span,</span>
<span class="sd">    which is used in the trace visualizer.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">trace_name</span><span class="p">:</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trace_name</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">get_active_trace_id</span><span class="p">():</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">start_span</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">start_trace</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="beeline.Beeline.send_all">
    <p>def <span class="ident">send_all</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>send all spans in the trace stack, regardless of their
state</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.Beeline.send_all', this);">Show source &equiv;</a></p>
  <div id="source-beeline.Beeline.send_all" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">send_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; send all spans in the trace stack, regardless of their</span>
<span class="sd">    state</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">span</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">get_active_span</span><span class="p">()</span>
    <span class="k">while</span> <span class="n">span</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">span</span><span class="o">.</span><span class="n">is_root</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">finish_trace</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">finish_span</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>
        <span class="n">span</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">get_active_span</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="beeline.Beeline.send_event">
    <p>def <span class="ident">send_event</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>DEPRECATED: Sends the currently active event (current span),
if it exists.</p>
<p>There must be one call to <code>send_event</code> for each call to <code>new_event</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.Beeline.send_event', this);">Show source &equiv;</a></p>
  <div id="source-beeline.Beeline.send_event" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">send_event</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; DEPRECATED: Sends the currently active event (current span),</span>
<span class="sd">    if it exists.</span>
<span class="sd">    There must be one call to `send_event` for each call to `new_event`.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">span</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">get_active_span</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">span</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">span</span><span class="o">.</span><span class="n">is_root</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">finish_trace</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">finish_span</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="beeline.Beeline.send_now">
    <p>def <span class="ident">send_now</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>DEPRECATED - to be removed in a future release</p>
<p>Create an event and enqueue it immediately. Does not work with
<a href="#beeline.add_field"><code>add_field</code></a> - this is equivalent to calling <code>libhoney.send_now</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.Beeline.send_now', this);">Show source &equiv;</a></p>
  <div id="source-beeline.Beeline.send_now" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">send_now</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; DEPRECATED - to be removed in a future release</span>
<span class="sd">    Create an event and enqueue it immediately. Does not work with</span>
<span class="sd">    `beeline.add_field` - this is equivalent to calling `libhoney.send_now`</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">new_event</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">ev</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_run_hooks_and_send</span><span class="p">(</span><span class="n">ev</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="beeline.Beeline.traced">
    <p>def <span class="ident">traced</span>(</p><p>self, name, trace_id=None, parent_id=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.Beeline.traced', this);">Show source &equiv;</a></p>
  <div id="source-beeline.Beeline.traced" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">traced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">trace_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">traced_impl</span><span class="p">(</span><span class="n">tracer_fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tracer</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">trace_id</span><span class="o">=</span><span class="n">trace_id</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="n">parent_id</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="beeline.Beeline.traced_thread">
    <p>def <span class="ident">traced_thread</span>(</p><p>self, fn)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.Beeline.traced_thread', this);">Show source &equiv;</a></p>
  <div id="source-beeline.Beeline.traced_thread" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">traced_thread</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
    <span class="n">trace_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="o">.</span><span class="n">_trace</span> <span class="o">=</span> <span class="n">trace_copy</span>
        <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapped</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="beeline.Beeline.tracer">
    <p>def <span class="ident">tracer</span>(</p><p>self, name, trace_id=None, parent_id=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-beeline.Beeline.tracer', this);">Show source &equiv;</a></p>
  <div id="source-beeline.Beeline.tracer" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">tracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">trace_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_impl</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">trace_id</span><span class="o">=</span><span class="n">trace_id</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="n">parent_id</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="beeline.Beeline.client" class="name">var <span class="ident">client</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="beeline.Beeline.debug" class="name">var <span class="ident">debug</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="beeline.Beeline.presend_hook" class="name">var <span class="ident">presend_hook</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="beeline.Beeline.sampler_hook" class="name">var <span class="ident">sampler_hook</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="beeline.Beeline.tracer_impl" class="name">var <span class="ident">tracer_impl</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

    <h2 class="section-title" id="header-submodules">Sub-modules</h2>
      <div class="item">
      <p class="name"><a href="aiotrace.m.html">beeline.aiotrace</a></p>
      
  
    <div class="desc"><p>Asynchronous tracer implementation.</p>
<p>This requires Python 3.7, because it uses the contextvars module.</p></div>

      </div>
      <div class="item">
      <p class="name"><a href="internal.m.html">beeline.internal</a></p>
      
  

      </div>
      <div class="item">
      <p class="name"><a href="middleware/index.html">beeline.middleware</a></p>
      
  

      </div>
      <div class="item">
      <p class="name"><a href="patch/index.html">beeline.patch</a></p>
      
  

      </div>
      <div class="item">
      <p class="name"><a href="test_async.m.html">beeline.test_async</a></p>
      
  

      </div>
      <div class="item">
      <p class="name"><a href="test_internal.m.html">beeline.test_internal</a></p>
      
  

      </div>
      <div class="item">
      <p class="name"><a href="test_suite.m.html">beeline.test_suite</a></p>
      
  

      </div>
      <div class="item">
      <p class="name"><a href="trace.m.html">beeline.trace</a></p>
      
  

      </div>
      <div class="item">
      <p class="name"><a href="version.m.html">beeline.version</a></p>
      
  

      </div>
  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
